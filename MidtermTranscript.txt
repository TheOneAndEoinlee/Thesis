So. And welcome to my midterm presentation on my project Cellular Automata Inspired Mechanical Metamaterial. Title pending. So I will - this is the structure of the presentation. So I'll give you a quick motivation and background for the project and the criteria that I've established for intelligent materials, I'll introduce the inspiration and approach for the project cellular automata, and then I'll go into how I will model complex elementary cellular automata mechanically. And then I will go into how I went about integrating the mechanical implementation and with the tessellation of these unit cells, and how I interconnect them. And then I overview some how I validated the approach with pseudo-rigid body model simulations and physical prototyping.

And then I'll go into the conclusions and the future. So for the motivation and background - So, for the general approach, materials are the substrate we make things out of and generally when we choose a material for a certain application, we optimize whatever that material's properties are for that particular application - for example, stiffness, or in some cases Poisson's ratio, wear resistance, etc.

Metamaterials are materials that we architect the structure of such that we can get properties outside of the natural range - such as negative Poisson's ratio, non-linear stiffness, negative refractive indices, different thermal expansions that aren't possible etc. And recently, there's been a field developing called intelligent metamaterials or computational metamaterials where the main objective is to try to imbue a new material property of computation or information processing inherited in the material itself based on how we design the structure.

The potential applications of this could be reactive materials or adaptive materials that based once they're manufactured, they can respond to their environment and change their material properties as a result or transmit information somewhere else as a distributed system of processing information.

And so to conceptualize the approach towards this - designing some sort of mechanical metamaterial, intelligent material. I structured some requirements. So for one it has to be tessellated, there can be no central processing or external parts, it has to work entirely by tessellation of individual unit cells.

Those unit cells should be able to hold a certain state for memory - so that this is the information that they they hold - to have some sort of memory. They need to be able to process that memory in some way by some elementary computation or logic and ideally, they should be able to communicate between cells, their states and compute based on more local interactions rather than solely isolated.

The relevance of this is that emerging properties can come from these tessellated simple structures that when the local interactions - it emerges from local interactions - you can get some complicated emergent properties. A single neuron can't do much computation on its own, but integrated into an interconnected system, you can get much more intelligent and much more interesting properties.

And the approach that I will be taking is compliant mechanisms because of their inherent scalability, because they are scale-free, frictionless and resistant to wear. So the background of how I'm going to approach this, is through the structure of cellular automata which are mathematical frameworks that have a grid of cells that have certain states and they interact.

So, the two most famous examples of this are Conway's Game of Life which is a two-dimensional cellular automaton. In each generation or frame in this animation, each cell updates depending on the number of live neighbours it has, whether it's on or off. On the right is elementary cellular automata which is a one-dimensional - time is on the vertical axis. So in each generation, each cell updates based on the configuration of states of itself and its neighbors.

Here one particular example of this is - and this is the visualization of how the process works - this is a specific rule known as Rule 110, you only need to know that the numbering exists in this system. But basically, this structure in the middle shows based on any of the possible 8 configurations of three cells, what will the central cell be in the next generation? And by repeated and recursive application of this transition rule, you can get very complex and emergent behaviors.

Most notably of which is the universality of this particular rule. So that means that it is Turing complete and it has been proven in 2004 by Matthew Cook and Steven Wolfram that this very simple rule, which is just a simple logic function, can get very complex, emergent properties that are universally complete. The exact process for this is known as the cyclic tag system, but the details aren't relevant, but just to show that very simple rules can exhibit emergent complex behavior. So that shows the promise of this approach for what I'm trying to create - intelligent metamaterials.

So the research question that I have is the design of a cellular automata inspired mechanical compliant metamaterial with an arbitrary transition function. So we don't want to make just one, we want to make a general approach to this problem. So how I will take the elementary cellular automata as the approach because they're simpler and more approachable, but as a stepping stone.

So the approach that I'm taking is based on bistable buckling beam mechanical logic, where a binary state can be stored in the snapping position of a bistable beam. So this illustration on the left is off, right is on. And by interconnecting these beams with springs you can create very simple logic gates.

For example, an OR gate where you have multiple bistable beams that feed into an output bistable beam. And by being connected by stiff springs. And the result is that you can get some sort of logical behavior where depending on the configuration the final beam is either buckled or not.

So this is an OR gate. And but you can represent this quite simply in the input space - on each axis is an input and the color of the vertex is the output of the node. So this represents the truth table for an OR gate which is notably a linearly separable function, so you can draw a single plane that separates the off configurations from the on configurations. This is important for later, this is why we can model this function with a single bistable beam.

Similarly, an AND gate is a linear logical function, where if you just decrease the stiffness of the springs, it requires both inputs to be activated in order to overcome the force threshold for the output bistable beam. But elementary cellular automata don't have two inputs, they take three inputs as their input. So you need three different input weights. So the necessary transformation of this plane is into the three dimensional input space for the three different states - the state of its left neighbor and the state of its right neighbor.

And I can illustrate how the variation of the stiffness affects the orientation of this plane in space - so that if you model it - if you vary the stiffness it changes the orientation. This is just a visualization to show how you can interact with and visualize this system and you can create multiple rules.

Now, the problem is most of the interesting cellular automata are non-linear in that they require two planes to separate the on-states from the off-states. This is because if that were not the case, usually it will tend towards an extreme state where everything is on or everything is off by necessity, because the on-states will just propagate and fill the entire plane.

So with one bistable beam as output, it has two possible states and one threshold of the maximum force. But if we create a tri-stable element by orienting them orthogonally like this, we can have three possible states and two force thresholds to overcome. So this is the general conceptual approach I'll be taking where we have this tri-stable behavior with three input states, connecting to one tri-stable output state and this represents some logical function that will implement a cellular automaton.

A simple representation of this, a linear model of it, is a bi-threshold logic gate where you simply weigh up the inputs which are 0 and 1 multiplied by a certain set of weights and if that sum is above the first threshold then it's on and if it's above the second threshold then it's off again. So this would represent one unit cell of the system and if we tessellate them we can interconnect them as shown in the diagram where the green goes to itself, red goes to its left neighbor and blue goes to its right neighbor.

And then if we actuate them all at the same time, and feed the state information back as inputs, then you can get the cellular automata behavior where the cell updates each generation. So this is the general, sorry this is the general conceptual approach. Now we're going to go into the specific mechanical embodiment.

So here's the different representations of this idea - the conceptual mechanism is this continuous compliant mechanism but there's also the lumped compliance mechanism and a simple representation of the pseudo-rigid body model that I will take forward because it's a simpler representation and abstracts away the unnecessary complexity. But this is just the logical gate, the interconnection is the actual difficult part.

And the approach that I took requires these three different components that are all necessary because of each other but I will lead you through them one by one. So the first is how do we do the clocking? So how do we actually actuate and feed in the signal?

So if you imagine a simple two-bar linkage like this in a singularity configuration - if we are trying to actuate the bottom endpoint, we don't know which direction the beam will move, the center point will move. But if we apply a small force to either left or right then that actuation, that small force will be magnified and we can use that as output. And if we can use the state as a determiner of which way it will actuate. So we can connect the output of that bifurcation to the input of the state element.

But, so sorry let me just say again - we can determine, we can connect the state of the element to determine which way the bifurcation element bifurcates. And then we can connect the output of the bifurcation element back to the input of the state element and this is the equivalent to the green line.

Now, the problem with this approach, that should work, the problem with this approach is that this is completely symmetric. There's no way that the signal can be cyclical because it'll just find a certain equilibrium and it will never be able to break out of that equilibrium.

So, what we need to do is - the solution that I have to this problem is tension-only springs. So, the problem we have is in this middle configuration, the position of the input actually has an impact on the bifurcation element, we do not want this. And likewise we don't want the position of the input to affect the neighboring inputs for the bifurcation element.

We want only the top spring to determine the bifurcation of the bifurcation mechanism. That's why if we introduce a nonlinear spring, which does not generate any force in compression, but is only in tension as illustrated here - then we alleviate the problem, break the symmetry of the mechanism and allow cyclical computation to occur.

And the corollary of this is that we also need some way of resetting the state mechanism back to the ground state after the bifurcation mechanism has locked in that state. So focusing on this state element in this animation - you'll see that the state has made the bifurcation element bifurcate, but then we reset it, and it allows it to compute the result of the computation, bearing in mind that the states of its neighbors, of course, influence it.

So in summary, the three mechanisms for interconnection and creating the input and interconnection: the periodic arrangement of the cells requires the connection of each input to each output. So each bifurcation has to be connected to the inputs of both neighbors and likewise the input has to be connected to the bifurcations of both neighbors.

What this looks like when tiling these out of plane is the easiest way of doing this and you can see the interconnection creates this back and forth system, where the outputs are connected to the inputs of the neighbors. And because bearing in mind that these are tension only springs allows this continuous computation.

So this is the model. And implementing this in simulation was done with a PRBM and the particular parameters that are controllable and how I have defined the parameters for the pseudo-rigid body model would be important. But in summary:

The result of this is that we can relate the stiffnesses of the input springs to the logical rule of the cellular automata. So this next figure I'll walk you through - it's a bit complex. Each of these blue lines - the blue line, the red line, and the green line - correspond to the stiffness of the blue spring, the green spring, and the red spring. And the position of this point along the input displacement is the magnitude of displacement this point will displace when it's turned on.

And the cyan, magenta and yellow lines are the sums of the stiffnesses of pairs of input springs, and the black line is the total stiffness of all the springs. What's important to note is the relationship of these stiffnesses relative to these critical stiffnesses here, which are the threshold stiffnesses beyond which the mechanism will snap through.

You can see that as I change the stiffnesses, the planes will change orientation relative to the critical stiffnesses and sometimes they exceed and sometimes they don't and that will determine the snapping through behavior. This particular arrangement is Rule 110 as we talked about earlier. So, the stiffnesses are three possible parameters that we can adjust.

And another parameter that we can adjust is modifying the maximum input displacement. And what this does is it changes the relative stiffnesses of the two critical snapping stiffnesses. So what that effectively does is it changes the separation of the planes, because one of the stiffnesses will change greater than the other one, but the inputs don't change.

The result of this is a particular rule, and I can show how this looks in simulation and the right hand side is the expected behavior as it evolves through the states. And you can notice that it follows the behavior of Rule 110 as predicted. And this is basically just determined by the input displacement and the relative stiffnesses, and the force-displacement behavior of the state element.

So, to show that I can modify these parameters - I don't have the animation rendered because it took a while - but I have tested in simulation that I can generate other rules just by modifying those parameters - input displacement, and the three stiffnesses.

So to validate this idea mechanically, but since we only needed a pseudo-rigid body model, which might not necessarily track with reality, I made some 3D printed prototypes of an embodiment of this idea. The tension only springs I modeled as a sort of regular spring with the stiffness I require coupled in series with essentially a string or cable that buckles completely in compression but becomes taught in tension and carries the force.

Not pictured here is the reset mechanism which resets the mechanism back to 0 after the bifurcation state has been locked in. I also don't have a video of the prototype, but that will go here for the final presentation as well. Ideally I would like to do point tracking of the paper to really track it precisely and see how well it tracks with my pseudo-rigid body model simulations.

So in conclusion: Where did we start from and where did we get? The idea behind this is to create a mechanical metamaterial which has unit cell states, computation, and interconnection - which is a potential embodiment for mechanical intelligent metamaterials.

The approach that we took is by trying to embody elementary cellular automata which also have all the properties required of an intelligent metamaterial if it were embodied. The approach that we took to embody these rules of the cellular automata is by reformulating them as bi-threshold functions. So the majority of these cellular automata can be embodied as these bi-threshold functions using the tri-stable element as a potential route for mechanical implementation of this bi-threshold element.

And the finer details of how we tested and interconnected these unit cells, we get a fully formed mechanical embodiment of the cellular automata behavior, which while complex, qualifies for the requirements and is tessellated. It has state elements, computation, and interconnection. So what we achieved essentially is an integrated tessellated tri-stable mechanism for mechanical computation.

We showed a pseudo-rigid body model representation of Rule 110 and others, and we've validated the result of that simulation through prototyping demonstration. A future direction of this project is that it shows the potential for this approach towards developing intelligent metamaterials, and this was a first step and it was one-dimensional. Cellular automata are a wide field with many potential two and three-dimensional embodiments.

Another potential approach would be to manufacture this at the microscale where it may be more feasible and useful to see the benefits rather than at a large scale with all the problems that entails in manufacturing. That is the end of my presentation. I hope that was clear, and I didn't lose you along the way. Any questions or feedback?